#version 330 core

in vec4 outColor;
in vec3 outPos;
in vec3 outNormal;

uniform vec4 ambientColor;
uniform float ambientIntensity;

uniform vec4 lightColor;
uniform vec4 lightPos;

uniform vec4 cameraPos;

uniform vec4 diffuseColor;
uniform vec4 specularColor;
uniform float smoothness;

//uniform vec4 tintColor;
//uniform sampler2D tex1;
//uniform sampler2D tex2;

out vec4 fragcolor;

vec3 GammaToLinearSpace (vec3 value)
{
    return vec3(pow(value.r, 2.2), pow(value.g, 2.2), pow(value.b, 2.2));
}

vec3 LinearToGammaSpace (vec3 value)
{
    return vec3(pow(value.r, 0.45454545), pow(value.g, 0.45454545), pow(value.b, 0.45454545));
}

vec3 FresnelTerm (vec3 F0, float cosA)
{
	float t = 1-cosA;
	t = t*t;
	t = t*t*(1-cosA);
    return F0 + (1-F0) * t;
};

float GGXTerm (float NdotH, float roughness)
{
    float a2 = roughness * roughness;
    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f;
    return a2 / (d * d + 1e-7f);
};

float SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)
{

    float a          = roughness;
    float a2         = a * a;

    float lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);
    float lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);

    return 0.5f / (lambdaV + lambdaL + 1e-5f); 
};

//“—æ≠‘§≥À¡ÀPI
void main()
{
	vec3 amcolor = GammaToLinearSpace(ambientColor.rgb);
	vec3 diffcolor = GammaToLinearSpace(diffuseColor.rgb);
	vec3 lightcolor = GammaToLinearSpace(lightColor.rgb);
	vec3 speccolor = GammaToLinearSpace(specularColor.rgb);

	vec3 L = normalize(lightPos.xyz);
	vec3 N = normalize(outNormal);
	vec3 V = normalize(cameraPos.xyz - outPos);
	vec3 H = normalize(L+V);

	float ndl = clamp(dot(N, L), 0.0, 1.0);
	float ndv = clamp(dot(N, V), 0.0, 1.0);
	float ndh = clamp(dot(N, H), 0.0, 1.0);
	float ldh = clamp(dot(L, H), 0.0, 1.0);

	vec3 ambient = amcolor * diffcolor;
	
	vec3 diffuse = ndl * lightcolor * diffcolor;

	float roughness = max(1-smoothness, 0.002);
    float G = SmithJointGGXVisibilityTerm (ndl, ndv, roughness);
    float D = GGXTerm (ndh, roughness);
	vec3 F = FresnelTerm (speccolor, ldh);
	vec3 specular = ndl * lightcolor * G * D * F;

	vec3 color = LinearToGammaSpace(ambient + diffuse + specular);
	fragcolor = vec4(color, 1.0f);
}